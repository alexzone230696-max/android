/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.tonapi.models.Account
import io.tonapi.models.AccountEvent
import io.tonapi.models.AccountEvents
import io.tonapi.models.Accounts
import io.tonapi.models.DnsExpiring
import io.tonapi.models.DomainNames
import io.tonapi.models.FoundAccounts
import io.tonapi.models.GaslessEstimateRequestMessagesInner
import io.tonapi.models.GetAccountDiff200Response
import io.tonapi.models.GetAccountPublicKey200Response
import io.tonapi.models.GetAccountsRequest
import io.tonapi.models.InlineObject
import io.tonapi.models.JettonBalance
import io.tonapi.models.JettonOperations
import io.tonapi.models.JettonsBalances
import io.tonapi.models.Multisigs
import io.tonapi.models.NftItems
import io.tonapi.models.Subscriptions
import io.tonapi.models.TraceIDs

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import io.infrastructure.ApiClient
import io.infrastructure.ApiResponse
import io.infrastructure.ClientException
import io.infrastructure.ClientError
import io.infrastructure.ServerException
import io.infrastructure.ServerError
import io.infrastructure.MultiValueMap
import io.infrastructure.PartConfig
import io.infrastructure.RequestConfig
import io.infrastructure.RequestMethod
import io.infrastructure.ResponseType
import io.infrastructure.Success
import io.infrastructure.toMultiValue

class AccountsApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun accountDnsBackResolve(accountId: kotlin.String) : DomainNames {
        val localVarResponse = accountDnsBackResolveWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DomainNames
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun accountDnsBackResolveWithHttpInfo(accountId: kotlin.String) : ApiResponse<DomainNames?> {
        val localVariableConfig = accountDnsBackResolveRequestConfig(accountId = accountId)

        return request<Unit, DomainNames>(
            localVariableConfig
        )
    }

    fun accountDnsBackResolveRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/dns/backresolve".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun emulateMessageToAccountEvent(accountId: kotlin.String, gaslessEstimateRequestMessagesInner: GaslessEstimateRequestMessagesInner, acceptLanguage: kotlin.String? = "en", ignoreSignatureCheck: kotlin.Boolean? = null) : AccountEvent {
        val localVarResponse = emulateMessageToAccountEventWithHttpInfo(accountId = accountId, gaslessEstimateRequestMessagesInner = gaslessEstimateRequestMessagesInner, acceptLanguage = acceptLanguage, ignoreSignatureCheck = ignoreSignatureCheck)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun emulateMessageToAccountEventWithHttpInfo(accountId: kotlin.String, gaslessEstimateRequestMessagesInner: GaslessEstimateRequestMessagesInner, acceptLanguage: kotlin.String?, ignoreSignatureCheck: kotlin.Boolean?) : ApiResponse<AccountEvent?> {
        val localVariableConfig = emulateMessageToAccountEventRequestConfig(accountId = accountId, gaslessEstimateRequestMessagesInner = gaslessEstimateRequestMessagesInner, acceptLanguage = acceptLanguage, ignoreSignatureCheck = ignoreSignatureCheck)

        return request<GaslessEstimateRequestMessagesInner, AccountEvent>(
            localVariableConfig
        )
    }

    fun emulateMessageToAccountEventRequestConfig(accountId: kotlin.String, gaslessEstimateRequestMessagesInner: GaslessEstimateRequestMessagesInner, acceptLanguage: kotlin.String?, ignoreSignatureCheck: kotlin.Boolean?) : RequestConfig<GaslessEstimateRequestMessagesInner> {
        val localVariableBody = gaslessEstimateRequestMessagesInner
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ignoreSignatureCheck != null) {
                    put("ignore_signature_check", listOf(ignoreSignatureCheck.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/accounts/{account_id}/events/emulate".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccount(accountId: kotlin.String) : Account {
        val localVarResponse = getAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Account
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<Account?> {
        val localVariableConfig = getAccountRequestConfig(accountId = accountId)

        return request<Unit, Account>(
            localVariableConfig
        )
    }

    fun getAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountDiff(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : GetAccountDiff200Response {
        val localVarResponse = getAccountDiffWithHttpInfo(accountId = accountId, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccountDiff200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountDiffWithHttpInfo(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : ApiResponse<GetAccountDiff200Response?> {
        val localVariableConfig = getAccountDiffRequestConfig(accountId = accountId, startDate = startDate, endDate = endDate)

        return request<Unit, GetAccountDiff200Response>(
            localVariableConfig
        )
    }

    fun getAccountDiffRequestConfig(accountId: kotlin.String, startDate: kotlin.Long, endDate: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("start_date", listOf(startDate.toString()))
                put("end_date", listOf(endDate.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/diff".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountDnsExpiring(accountId: kotlin.String, period: kotlin.Int? = null) : DnsExpiring {
        val localVarResponse = getAccountDnsExpiringWithHttpInfo(accountId = accountId, period = period)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DnsExpiring
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountDnsExpiringWithHttpInfo(accountId: kotlin.String, period: kotlin.Int?) : ApiResponse<DnsExpiring?> {
        val localVariableConfig = getAccountDnsExpiringRequestConfig(accountId = accountId, period = period)

        return request<Unit, DnsExpiring>(
            localVariableConfig
        )
    }

    fun getAccountDnsExpiringRequestConfig(accountId: kotlin.String, period: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (period != null) {
                    put("period", listOf(period.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/dns/expiring".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountEvent(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String? = "en", subjectOnly: kotlin.Boolean? = false) : AccountEvent {
        val localVarResponse = getAccountEventWithHttpInfo(accountId = accountId, eventId = eventId, acceptLanguage = acceptLanguage, subjectOnly = subjectOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvent
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountEventWithHttpInfo(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String?, subjectOnly: kotlin.Boolean?) : ApiResponse<AccountEvent?> {
        val localVariableConfig = getAccountEventRequestConfig(accountId = accountId, eventId = eventId, acceptLanguage = acceptLanguage, subjectOnly = subjectOnly)

        return request<Unit, AccountEvent>(
            localVariableConfig
        )
    }

    fun getAccountEventRequestConfig(accountId: kotlin.String, eventId: kotlin.String, acceptLanguage: kotlin.String?, subjectOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (subjectOnly != null) {
                    put("subject_only", listOf(subjectOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/events/{event_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"event_id"+"}", encodeURIComponent(eventId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountEvents(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", initiator: kotlin.Boolean? = false, subjectOnly: kotlin.Boolean? = false, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        val localVarResponse = getAccountEventsWithHttpInfo(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, initiator = initiator, subjectOnly = subjectOnly, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountEventsWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, initiator: kotlin.Boolean?, subjectOnly: kotlin.Boolean?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountEventsRequestConfig(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, initiator = initiator, subjectOnly = subjectOnly, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    fun getAccountEventsRequestConfig(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, initiator: kotlin.Boolean?, subjectOnly: kotlin.Boolean?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (initiator != null) {
                    put("initiator", listOf(initiator.toString()))
                }
                if (subjectOnly != null) {
                    put("subject_only", listOf(subjectOnly.toString()))
                }
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/events".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountExtraCurrencyHistoryByID(accountId: kotlin.String, id: kotlin.Int, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        val localVarResponse = getAccountExtraCurrencyHistoryByIDWithHttpInfo(accountId = accountId, id = id, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountExtraCurrencyHistoryByIDWithHttpInfo(accountId: kotlin.String, id: kotlin.Int, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        val localVariableConfig = getAccountExtraCurrencyHistoryByIDRequestConfig(accountId = accountId, id = id, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    fun getAccountExtraCurrencyHistoryByIDRequestConfig(accountId: kotlin.String, id: kotlin.Int, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/extra-currency/{id}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonBalance(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>? = null, supportedExtensions: kotlin.collections.List<kotlin.String>? = null) : JettonBalance {
        val localVarResponse = getAccountJettonBalanceWithHttpInfo(accountId = accountId, jettonId = jettonId, currencies = currencies, supportedExtensions = supportedExtensions)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonBalance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonBalanceWithHttpInfo(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?, supportedExtensions: kotlin.collections.List<kotlin.String>?) : ApiResponse<JettonBalance?> {
        val localVariableConfig = getAccountJettonBalanceRequestConfig(accountId = accountId, jettonId = jettonId, currencies = currencies, supportedExtensions = supportedExtensions)

        return request<Unit, JettonBalance>(
            localVariableConfig
        )
    }

    fun getAccountJettonBalanceRequestConfig(accountId: kotlin.String, jettonId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?, supportedExtensions: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencies != null) {
                    put("currencies", toMultiValue(currencies.toList(), "csv"))
                }
                if (supportedExtensions != null) {
                    put("supported_extensions", toMultiValue(supportedExtensions.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/{jetton_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"jetton_id"+"}", encodeURIComponent(jettonId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getAccountJettonHistoryByID(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        @Suppress("DEPRECATION")
        val localVarResponse = getAccountJettonHistoryByIDWithHttpInfo(accountId = accountId, jettonId = jettonId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getAccountJettonHistoryByIDWithHttpInfo(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = getAccountJettonHistoryByIDRequestConfig(accountId = accountId, jettonId = jettonId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    @Deprecated(message = "This operation is deprecated.")
    fun getAccountJettonHistoryByIDRequestConfig(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/{jetton_id}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"jetton_id"+"}", encodeURIComponent(jettonId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonsBalances(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>? = null, supportedExtensions: kotlin.collections.List<kotlin.String>? = null) : JettonsBalances {
        val localVarResponse = getAccountJettonsBalancesWithHttpInfo(accountId = accountId, currencies = currencies, supportedExtensions = supportedExtensions)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonsBalances
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonsBalancesWithHttpInfo(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?, supportedExtensions: kotlin.collections.List<kotlin.String>?) : ApiResponse<JettonsBalances?> {
        val localVariableConfig = getAccountJettonsBalancesRequestConfig(accountId = accountId, currencies = currencies, supportedExtensions = supportedExtensions)

        return request<Unit, JettonsBalances>(
            localVariableConfig
        )
    }

    fun getAccountJettonsBalancesRequestConfig(accountId: kotlin.String, currencies: kotlin.collections.List<kotlin.String>?, supportedExtensions: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currencies != null) {
                    put("currencies", toMultiValue(currencies.toList(), "csv"))
                }
                if (supportedExtensions != null) {
                    put("supported_extensions", toMultiValue(supportedExtensions.toList(), "csv"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountJettonsHistory(accountId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long? = null) : JettonOperations {
        val localVarResponse = getAccountJettonsHistoryWithHttpInfo(accountId = accountId, limit = limit, beforeLt = beforeLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonOperations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountJettonsHistoryWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long?) : ApiResponse<JettonOperations?> {
        val localVariableConfig = getAccountJettonsHistoryRequestConfig(accountId = accountId, limit = limit, beforeLt = beforeLt)

        return request<Unit, JettonOperations>(
            localVariableConfig
        )
    }

    fun getAccountJettonsHistoryRequestConfig(accountId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/jettons/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountMultisigs(accountId: kotlin.String) : Multisigs {
        val localVarResponse = getAccountMultisigsWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Multisigs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountMultisigsWithHttpInfo(accountId: kotlin.String) : ApiResponse<Multisigs?> {
        val localVariableConfig = getAccountMultisigsRequestConfig(accountId = accountId)

        return request<Unit, Multisigs>(
            localVariableConfig
        )
    }

    fun getAccountMultisigsRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/multisigs".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountNftItems(accountId: kotlin.String, collection: kotlin.String? = null, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, indirectOwnership: kotlin.Boolean? = false) : NftItems {
        val localVarResponse = getAccountNftItemsWithHttpInfo(accountId = accountId, collection = collection, limit = limit, offset = offset, indirectOwnership = indirectOwnership)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftItems
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountNftItemsWithHttpInfo(accountId: kotlin.String, collection: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, indirectOwnership: kotlin.Boolean?) : ApiResponse<NftItems?> {
        val localVariableConfig = getAccountNftItemsRequestConfig(accountId = accountId, collection = collection, limit = limit, offset = offset, indirectOwnership = indirectOwnership)

        return request<Unit, NftItems>(
            localVariableConfig
        )
    }

    fun getAccountNftItemsRequestConfig(accountId: kotlin.String, collection: kotlin.String?, limit: kotlin.Int?, offset: kotlin.Int?, indirectOwnership: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (collection != null) {
                    put("collection", listOf(collection.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (indirectOwnership != null) {
                    put("indirect_ownership", listOf(indirectOwnership.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/nfts".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountPublicKey(accountId: kotlin.String) : GetAccountPublicKey200Response {
        val localVarResponse = getAccountPublicKeyWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAccountPublicKey200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountPublicKeyWithHttpInfo(accountId: kotlin.String) : ApiResponse<GetAccountPublicKey200Response?> {
        val localVariableConfig = getAccountPublicKeyRequestConfig(accountId = accountId)

        return request<Unit, GetAccountPublicKey200Response>(
            localVariableConfig
        )
    }

    fun getAccountPublicKeyRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/publickey".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountSubscriptions(accountId: kotlin.String) : Subscriptions {
        val localVarResponse = getAccountSubscriptionsWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Subscriptions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountSubscriptionsWithHttpInfo(accountId: kotlin.String) : ApiResponse<Subscriptions?> {
        val localVariableConfig = getAccountSubscriptionsRequestConfig(accountId = accountId)

        return request<Unit, Subscriptions>(
            localVariableConfig
        )
    }

    fun getAccountSubscriptionsRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/subscriptions".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountTraces(accountId: kotlin.String, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100) : TraceIDs {
        val localVarResponse = getAccountTracesWithHttpInfo(accountId = accountId, beforeLt = beforeLt, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TraceIDs
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountTracesWithHttpInfo(accountId: kotlin.String, beforeLt: kotlin.Long?, limit: kotlin.Int?) : ApiResponse<TraceIDs?> {
        val localVariableConfig = getAccountTracesRequestConfig(accountId = accountId, beforeLt = beforeLt, limit = limit)

        return request<Unit, TraceIDs>(
            localVariableConfig
        )
    }

    fun getAccountTracesRequestConfig(accountId: kotlin.String, beforeLt: kotlin.Long?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/traces".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccounts(currency: kotlin.String? = null, getAccountsRequest: GetAccountsRequest? = null) : Accounts {
        val localVarResponse = getAccountsWithHttpInfo(currency = currency, getAccountsRequest = getAccountsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Accounts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountsWithHttpInfo(currency: kotlin.String?, getAccountsRequest: GetAccountsRequest?) : ApiResponse<Accounts?> {
        val localVariableConfig = getAccountsRequestConfig(currency = currency, getAccountsRequest = getAccountsRequest)

        return request<GetAccountsRequest, Accounts>(
            localVariableConfig
        )
    }

    fun getAccountsRequestConfig(currency: kotlin.String?, getAccountsRequest: GetAccountsRequest?) : RequestConfig<GetAccountsRequest> {
        val localVariableBody = getAccountsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (currency != null) {
                    put("currency", listOf(currency.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/accounts/_bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getJettonAccountHistoryByID(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : JettonOperations {
        val localVarResponse = getJettonAccountHistoryByIDWithHttpInfo(accountId = accountId, jettonId = jettonId, limit = limit, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as JettonOperations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getJettonAccountHistoryByIDWithHttpInfo(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<JettonOperations?> {
        val localVariableConfig = getJettonAccountHistoryByIDRequestConfig(accountId = accountId, jettonId = jettonId, limit = limit, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, JettonOperations>(
            localVariableConfig
        )
    }

    fun getJettonAccountHistoryByIDRequestConfig(accountId: kotlin.String, jettonId: kotlin.String, limit: kotlin.Int, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/jettons/{jetton_id}/accounts/{account_id}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"jetton_id"+"}", encodeURIComponent(jettonId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun reindexAccount(accountId: kotlin.String) : Unit {
        val localVarResponse = reindexAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }


    @Throws(IllegalStateException::class, IOException::class)
    fun reindexAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<Unit?> {
        val localVariableConfig = reindexAccountRequestConfig(accountId = accountId)

        return request<Unit, Unit>(
            localVariableConfig
        )
    }

    fun reindexAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/accounts/{account_id}/reindex".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun searchAccounts(name: kotlin.String) : FoundAccounts {
        val localVarResponse = searchAccountsWithHttpInfo(name = name)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as FoundAccounts
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun searchAccountsWithHttpInfo(name: kotlin.String) : ApiResponse<FoundAccounts?> {
        val localVariableConfig = searchAccountsRequestConfig(name = name)

        return request<Unit, FoundAccounts>(
            localVariableConfig
        )
    }

    fun searchAccountsRequestConfig(name: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("name", listOf(name.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/search",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
