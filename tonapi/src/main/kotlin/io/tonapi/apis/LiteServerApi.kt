/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.tonapi.models.GetAllRawShardsInfo200Response
import io.tonapi.models.GetOutMsgQueueSizes200Response
import io.tonapi.models.GetRawAccountState200Response
import io.tonapi.models.GetRawBlockProof200Response
import io.tonapi.models.GetRawBlockchainBlock200Response
import io.tonapi.models.GetRawBlockchainBlockHeader200Response
import io.tonapi.models.GetRawBlockchainBlockState200Response
import io.tonapi.models.GetRawConfig200Response
import io.tonapi.models.GetRawListBlockTransactions200Response
import io.tonapi.models.GetRawMasterchainInfo200Response
import io.tonapi.models.GetRawMasterchainInfoExt200Response
import io.tonapi.models.GetRawShardBlockProof200Response
import io.tonapi.models.GetRawShardInfo200Response
import io.tonapi.models.GetRawTime200Response
import io.tonapi.models.GetRawTransactions200Response
import io.tonapi.models.InlineObject
import io.tonapi.models.SendRawMessage200Response
import io.tonapi.models.SendRawMessageRequest

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import io.infrastructure.ApiClient
import io.infrastructure.ApiResponse
import io.infrastructure.ClientException
import io.infrastructure.ClientError
import io.infrastructure.ServerException
import io.infrastructure.ServerError
import io.infrastructure.MultiValueMap
import io.infrastructure.PartConfig
import io.infrastructure.RequestConfig
import io.infrastructure.RequestMethod
import io.infrastructure.ResponseType
import io.infrastructure.Success
import io.infrastructure.toMultiValue

class LiteServerApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAllRawShardsInfo(blockId: kotlin.String) : GetAllRawShardsInfo200Response {
        val localVarResponse = getAllRawShardsInfoWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetAllRawShardsInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAllRawShardsInfoWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetAllRawShardsInfo200Response?> {
        val localVariableConfig = getAllRawShardsInfoRequestConfig(blockId = blockId)

        return request<Unit, GetAllRawShardsInfo200Response>(
            localVariableConfig
        )
    }

    fun getAllRawShardsInfoRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_all_shards_info/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOutMsgQueueSizes() : GetOutMsgQueueSizes200Response {
        val localVarResponse = getOutMsgQueueSizesWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOutMsgQueueSizes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOutMsgQueueSizesWithHttpInfo() : ApiResponse<GetOutMsgQueueSizes200Response?> {
        val localVariableConfig = getOutMsgQueueSizesRequestConfig()

        return request<Unit, GetOutMsgQueueSizes200Response>(
            localVariableConfig
        )
    }

    fun getOutMsgQueueSizesRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_out_msg_queue_sizes",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawAccountState(accountId: kotlin.String, targetBlock: kotlin.String? = null) : GetRawAccountState200Response {
        val localVarResponse = getRawAccountStateWithHttpInfo(accountId = accountId, targetBlock = targetBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawAccountState200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawAccountStateWithHttpInfo(accountId: kotlin.String, targetBlock: kotlin.String?) : ApiResponse<GetRawAccountState200Response?> {
        val localVariableConfig = getRawAccountStateRequestConfig(accountId = accountId, targetBlock = targetBlock)

        return request<Unit, GetRawAccountState200Response>(
            localVariableConfig
        )
    }

    fun getRawAccountStateRequestConfig(accountId: kotlin.String, targetBlock: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (targetBlock != null) {
                    put("target_block", listOf(targetBlock.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_account_state/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockProof(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String? = null) : GetRawBlockProof200Response {
        val localVarResponse = getRawBlockProofWithHttpInfo(knownBlock = knownBlock, mode = mode, targetBlock = targetBlock)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockProof200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockProofWithHttpInfo(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String?) : ApiResponse<GetRawBlockProof200Response?> {
        val localVariableConfig = getRawBlockProofRequestConfig(knownBlock = knownBlock, mode = mode, targetBlock = targetBlock)

        return request<Unit, GetRawBlockProof200Response>(
            localVariableConfig
        )
    }

    fun getRawBlockProofRequestConfig(knownBlock: kotlin.String, mode: kotlin.Int, targetBlock: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("known_block", listOf(knownBlock.toString()))
                if (targetBlock != null) {
                    put("target_block", listOf(targetBlock.toString()))
                }
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block_proof",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlock(blockId: kotlin.String) : GetRawBlockchainBlock200Response {
        val localVarResponse = getRawBlockchainBlockWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlock200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawBlockchainBlock200Response?> {
        val localVariableConfig = getRawBlockchainBlockRequestConfig(blockId = blockId)

        return request<Unit, GetRawBlockchainBlock200Response>(
            localVariableConfig
        )
    }

    fun getRawBlockchainBlockRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlockHeader(blockId: kotlin.String, mode: kotlin.Int) : GetRawBlockchainBlockHeader200Response {
        val localVarResponse = getRawBlockchainBlockHeaderWithHttpInfo(blockId = blockId, mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlockHeader200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockHeaderWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int) : ApiResponse<GetRawBlockchainBlockHeader200Response?> {
        val localVariableConfig = getRawBlockchainBlockHeaderRequestConfig(blockId = blockId, mode = mode)

        return request<Unit, GetRawBlockchainBlockHeader200Response>(
            localVariableConfig
        )
    }

    fun getRawBlockchainBlockHeaderRequestConfig(blockId: kotlin.String, mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_block_header/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainBlockState(blockId: kotlin.String) : GetRawBlockchainBlockState200Response {
        val localVarResponse = getRawBlockchainBlockStateWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawBlockchainBlockState200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainBlockStateWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawBlockchainBlockState200Response?> {
        val localVariableConfig = getRawBlockchainBlockStateRequestConfig(blockId = blockId)

        return request<Unit, GetRawBlockchainBlockState200Response>(
            localVariableConfig
        )
    }

    fun getRawBlockchainBlockStateRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_state/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawConfig(blockId: kotlin.String, mode: kotlin.Int) : GetRawConfig200Response {
        val localVarResponse = getRawConfigWithHttpInfo(blockId = blockId, mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawConfig200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawConfigWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int) : ApiResponse<GetRawConfig200Response?> {
        val localVariableConfig = getRawConfigRequestConfig(blockId = blockId, mode = mode)

        return request<Unit, GetRawConfig200Response>(
            localVariableConfig
        )
    }

    fun getRawConfigRequestConfig(blockId: kotlin.String, mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_config_all/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawListBlockTransactions(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String? = null, lt: kotlin.Long? = null) : GetRawListBlockTransactions200Response {
        val localVarResponse = getRawListBlockTransactionsWithHttpInfo(blockId = blockId, mode = mode, count = count, accountId = accountId, lt = lt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawListBlockTransactions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawListBlockTransactionsWithHttpInfo(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String?, lt: kotlin.Long?) : ApiResponse<GetRawListBlockTransactions200Response?> {
        val localVariableConfig = getRawListBlockTransactionsRequestConfig(blockId = blockId, mode = mode, count = count, accountId = accountId, lt = lt)

        return request<Unit, GetRawListBlockTransactions200Response>(
            localVariableConfig
        )
    }

    fun getRawListBlockTransactionsRequestConfig(blockId: kotlin.String, mode: kotlin.Int, count: kotlin.Int, accountId: kotlin.String?, lt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
                put("count", listOf(count.toString()))
                if (accountId != null) {
                    put("account_id", listOf(accountId.toString()))
                }
                if (lt != null) {
                    put("lt", listOf(lt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/list_block_transactions/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawMasterchainInfo() : GetRawMasterchainInfo200Response {
        val localVarResponse = getRawMasterchainInfoWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawMasterchainInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawMasterchainInfoWithHttpInfo() : ApiResponse<GetRawMasterchainInfo200Response?> {
        val localVariableConfig = getRawMasterchainInfoRequestConfig()

        return request<Unit, GetRawMasterchainInfo200Response>(
            localVariableConfig
        )
    }

    fun getRawMasterchainInfoRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_masterchain_info",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawMasterchainInfoExt(mode: kotlin.Int) : GetRawMasterchainInfoExt200Response {
        val localVarResponse = getRawMasterchainInfoExtWithHttpInfo(mode = mode)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawMasterchainInfoExt200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawMasterchainInfoExtWithHttpInfo(mode: kotlin.Int) : ApiResponse<GetRawMasterchainInfoExt200Response?> {
        val localVariableConfig = getRawMasterchainInfoExtRequestConfig(mode = mode)

        return request<Unit, GetRawMasterchainInfoExt200Response>(
            localVariableConfig
        )
    }

    fun getRawMasterchainInfoExtRequestConfig(mode: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("mode", listOf(mode.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_masterchain_info_ext",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawShardBlockProof(blockId: kotlin.String) : GetRawShardBlockProof200Response {
        val localVarResponse = getRawShardBlockProofWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawShardBlockProof200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawShardBlockProofWithHttpInfo(blockId: kotlin.String) : ApiResponse<GetRawShardBlockProof200Response?> {
        val localVariableConfig = getRawShardBlockProofRequestConfig(blockId = blockId)

        return request<Unit, GetRawShardBlockProof200Response>(
            localVariableConfig
        )
    }

    fun getRawShardBlockProofRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_shard_block_proof/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawShardInfo(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : GetRawShardInfo200Response {
        val localVarResponse = getRawShardInfoWithHttpInfo(blockId = blockId, workchain = workchain, shard = shard, exact = exact)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawShardInfo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawShardInfoWithHttpInfo(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : ApiResponse<GetRawShardInfo200Response?> {
        val localVariableConfig = getRawShardInfoRequestConfig(blockId = blockId, workchain = workchain, shard = shard, exact = exact)

        return request<Unit, GetRawShardInfo200Response>(
            localVariableConfig
        )
    }

    fun getRawShardInfoRequestConfig(blockId: kotlin.String, workchain: kotlin.Int, shard: kotlin.Long, exact: kotlin.Boolean) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("workchain", listOf(workchain.toString()))
                put("shard", listOf(shard.toString()))
                put("exact", listOf(exact.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_shard_info/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawTime() : GetRawTime200Response {
        val localVarResponse = getRawTimeWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawTime200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawTimeWithHttpInfo() : ApiResponse<GetRawTime200Response?> {
        val localVariableConfig = getRawTimeRequestConfig()

        return request<Unit, GetRawTime200Response>(
            localVariableConfig
        )
    }

    fun getRawTimeRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_time",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawTransactions(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : GetRawTransactions200Response {
        val localVarResponse = getRawTransactionsWithHttpInfo(accountId = accountId, count = count, lt = lt, hash = hash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRawTransactions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawTransactionsWithHttpInfo(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : ApiResponse<GetRawTransactions200Response?> {
        val localVariableConfig = getRawTransactionsRequestConfig(accountId = accountId, count = count, lt = lt, hash = hash)

        return request<Unit, GetRawTransactions200Response>(
            localVariableConfig
        )
    }

    fun getRawTransactionsRequestConfig(accountId: kotlin.String, count: kotlin.Int, lt: kotlin.Long, hash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("count", listOf(count.toString()))
                put("lt", listOf(lt.toString()))
                put("hash", listOf(hash.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/liteserver/get_transactions/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendRawMessage(sendRawMessageRequest: SendRawMessageRequest) : SendRawMessage200Response {
        val localVarResponse = sendRawMessageWithHttpInfo(sendRawMessageRequest = sendRawMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SendRawMessage200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun sendRawMessageWithHttpInfo(sendRawMessageRequest: SendRawMessageRequest) : ApiResponse<SendRawMessage200Response?> {
        val localVariableConfig = sendRawMessageRequestConfig(sendRawMessageRequest = sendRawMessageRequest)

        return request<SendRawMessageRequest, SendRawMessage200Response>(
            localVariableConfig
        )
    }

    fun sendRawMessageRequestConfig(sendRawMessageRequest: SendRawMessageRequest) : RequestConfig<SendRawMessageRequest> {
        val localVariableBody = sendRawMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/liteserver/send_message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
