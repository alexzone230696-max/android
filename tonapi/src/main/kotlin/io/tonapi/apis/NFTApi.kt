/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.tonapi.models.AccountEvents
import io.tonapi.models.GetAccountsRequest
import io.tonapi.models.InlineObject
import io.tonapi.models.NftCollection
import io.tonapi.models.NftCollections
import io.tonapi.models.NftItem
import io.tonapi.models.NftItems
import io.tonapi.models.NftOperations

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import io.infrastructure.ApiClient
import io.infrastructure.ApiResponse
import io.infrastructure.ClientException
import io.infrastructure.ClientError
import io.infrastructure.ServerException
import io.infrastructure.ServerError
import io.infrastructure.MultiValueMap
import io.infrastructure.PartConfig
import io.infrastructure.RequestConfig
import io.infrastructure.RequestMethod
import io.infrastructure.ResponseType
import io.infrastructure.Success
import io.infrastructure.toMultiValue

class NFTApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getAccountNftHistory(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null) : NftOperations {
        val localVarResponse = getAccountNftHistoryWithHttpInfo(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftOperations
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getAccountNftHistoryWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?) : ApiResponse<NftOperations?> {
        val localVariableConfig = getAccountNftHistoryRequestConfig(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt)

        return request<Unit, NftOperations>(
            localVariableConfig
        )
    }

    fun getAccountNftHistoryRequestConfig(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/accounts/{account_id}/nfts/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getItemsFromCollection(accountId: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0) : NftItems {
        val localVarResponse = getItemsFromCollectionWithHttpInfo(accountId = accountId, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftItems
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getItemsFromCollectionWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<NftItems?> {
        val localVariableConfig = getItemsFromCollectionRequestConfig(accountId = accountId, limit = limit, offset = offset)

        return request<Unit, NftItems>(
            localVariableConfig
        )
    }

    fun getItemsFromCollectionRequestConfig(accountId: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/nfts/collections/{account_id}/items".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNftCollection(accountId: kotlin.String) : NftCollection {
        val localVarResponse = getNftCollectionWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftCollection
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNftCollectionWithHttpInfo(accountId: kotlin.String) : ApiResponse<NftCollection?> {
        val localVariableConfig = getNftCollectionRequestConfig(accountId = accountId)

        return request<Unit, NftCollection>(
            localVariableConfig
        )
    }

    fun getNftCollectionRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/nfts/collections/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNftCollectionItemsByAddresses(getAccountsRequest: GetAccountsRequest? = null) : NftCollections {
        val localVarResponse = getNftCollectionItemsByAddressesWithHttpInfo(getAccountsRequest = getAccountsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftCollections
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNftCollectionItemsByAddressesWithHttpInfo(getAccountsRequest: GetAccountsRequest?) : ApiResponse<NftCollections?> {
        val localVariableConfig = getNftCollectionItemsByAddressesRequestConfig(getAccountsRequest = getAccountsRequest)

        return request<GetAccountsRequest, NftCollections>(
            localVariableConfig
        )
    }

    fun getNftCollectionItemsByAddressesRequestConfig(getAccountsRequest: GetAccountsRequest?) : RequestConfig<GetAccountsRequest> {
        val localVariableBody = getAccountsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/nfts/collections/_bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNftCollections(limit: kotlin.Int? = 100, offset: kotlin.Int? = 0) : NftCollections {
        val localVarResponse = getNftCollectionsWithHttpInfo(limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftCollections
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNftCollectionsWithHttpInfo(limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<NftCollections?> {
        val localVariableConfig = getNftCollectionsRequestConfig(limit = limit, offset = offset)

        return request<Unit, NftCollections>(
            localVariableConfig
        )
    }

    fun getNftCollectionsRequestConfig(limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/nfts/collections",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getNftHistoryByID(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String? = "en", beforeLt: kotlin.Long? = null, startDate: kotlin.Long? = null, endDate: kotlin.Long? = null) : AccountEvents {
        @Suppress("DEPRECATION")
        val localVarResponse = getNftHistoryByIDWithHttpInfo(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AccountEvents
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    @Deprecated(message = "This operation is deprecated.")
    fun getNftHistoryByIDWithHttpInfo(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : ApiResponse<AccountEvents?> {
        @Suppress("DEPRECATION")
        val localVariableConfig = getNftHistoryByIDRequestConfig(accountId = accountId, limit = limit, acceptLanguage = acceptLanguage, beforeLt = beforeLt, startDate = startDate, endDate = endDate)

        return request<Unit, AccountEvents>(
            localVariableConfig
        )
    }

    @Deprecated(message = "This operation is deprecated.")
    fun getNftHistoryByIDRequestConfig(accountId: kotlin.String, limit: kotlin.Int, acceptLanguage: kotlin.String?, beforeLt: kotlin.Long?, startDate: kotlin.Long?, endDate: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                put("limit", listOf(limit.toString()))
                if (startDate != null) {
                    put("start_date", listOf(startDate.toString()))
                }
                if (endDate != null) {
                    put("end_date", listOf(endDate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/nfts/{account_id}/history".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNftItemByAddress(accountId: kotlin.String) : NftItem {
        val localVarResponse = getNftItemByAddressWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftItem
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNftItemByAddressWithHttpInfo(accountId: kotlin.String) : ApiResponse<NftItem?> {
        val localVariableConfig = getNftItemByAddressRequestConfig(accountId = accountId)

        return request<Unit, NftItem>(
            localVariableConfig
        )
    }

    fun getNftItemByAddressRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/nfts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getNftItemsByAddresses(getAccountsRequest: GetAccountsRequest? = null) : NftItems {
        val localVarResponse = getNftItemsByAddressesWithHttpInfo(getAccountsRequest = getAccountsRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as NftItems
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getNftItemsByAddressesWithHttpInfo(getAccountsRequest: GetAccountsRequest?) : ApiResponse<NftItems?> {
        val localVariableConfig = getNftItemsByAddressesRequestConfig(getAccountsRequest = getAccountsRequest)

        return request<GetAccountsRequest, NftItems>(
            localVariableConfig
        )
    }

    fun getNftItemsByAddressesRequestConfig(getAccountsRequest: GetAccountsRequest?) : RequestConfig<GetAccountsRequest> {
        val localVariableBody = getAccountsRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/nfts/_bulk",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
