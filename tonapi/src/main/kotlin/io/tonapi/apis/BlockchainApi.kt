/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.tonapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.tonapi.models.BlockchainAccountInspect
import io.tonapi.models.BlockchainBlock
import io.tonapi.models.BlockchainBlockShards
import io.tonapi.models.BlockchainBlocks
import io.tonapi.models.BlockchainConfig
import io.tonapi.models.BlockchainLibrary
import io.tonapi.models.BlockchainRawAccount
import io.tonapi.models.ExecGetMethodWithBodyForBlockchainAccountRequest
import io.tonapi.models.InlineObject
import io.tonapi.models.MethodExecutionResult
import io.tonapi.models.RawBlockchainConfig
import io.tonapi.models.ReducedBlocks
import io.tonapi.models.SendBlockchainMessageRequest
import io.tonapi.models.Transaction
import io.tonapi.models.Transactions
import io.tonapi.models.Validators

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import io.infrastructure.ApiClient
import io.infrastructure.ApiResponse
import io.infrastructure.ClientException
import io.infrastructure.ClientError
import io.infrastructure.ServerException
import io.infrastructure.ServerError
import io.infrastructure.MultiValueMap
import io.infrastructure.PartConfig
import io.infrastructure.RequestConfig
import io.infrastructure.RequestMethod
import io.infrastructure.ResponseType
import io.infrastructure.Success
import io.infrastructure.toMultiValue

class BlockchainApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://tonapi.io")
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun blockchainAccountInspect(accountId: kotlin.String) : BlockchainAccountInspect {
        val localVarResponse = blockchainAccountInspectWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainAccountInspect
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun blockchainAccountInspectWithHttpInfo(accountId: kotlin.String) : ApiResponse<BlockchainAccountInspect?> {
        val localVariableConfig = blockchainAccountInspectRequestConfig(accountId = accountId)

        return request<Unit, BlockchainAccountInspect>(
            localVariableConfig
        )
    }

    fun blockchainAccountInspectRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/inspect".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun downloadBlockchainBlockBoc(blockId: kotlin.String) : java.io.File {
        val localVarResponse = downloadBlockchainBlockBocWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as java.io.File
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun downloadBlockchainBlockBocWithHttpInfo(blockId: kotlin.String) : ApiResponse<java.io.File?> {
        val localVariableConfig = downloadBlockchainBlockBocRequestConfig(blockId = blockId)

        return request<Unit, java.io.File>(
            localVariableConfig
        )
    }

    fun downloadBlockchainBlockBocRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/octet-stream, application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/blocks/{block_id}/boc".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun execGetMethodForBlockchainAccount(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>? = null) : MethodExecutionResult {
        val localVarResponse = execGetMethodForBlockchainAccountWithHttpInfo(accountId = accountId, methodName = methodName, args = args)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MethodExecutionResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun execGetMethodForBlockchainAccountWithHttpInfo(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>?) : ApiResponse<MethodExecutionResult?> {
        val localVariableConfig = execGetMethodForBlockchainAccountRequestConfig(accountId = accountId, methodName = methodName, args = args)

        return request<Unit, MethodExecutionResult>(
            localVariableConfig
        )
    }

    fun execGetMethodForBlockchainAccountRequestConfig(accountId: kotlin.String, methodName: kotlin.String, args: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (args != null) {
                    put("args", toMultiValue(args.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/methods/{method_name}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"method_name"+"}", encodeURIComponent(methodName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun execGetMethodWithBodyForBlockchainAccount(accountId: kotlin.String, methodName: kotlin.String, execGetMethodWithBodyForBlockchainAccountRequest: ExecGetMethodWithBodyForBlockchainAccountRequest? = null) : MethodExecutionResult {
        val localVarResponse = execGetMethodWithBodyForBlockchainAccountWithHttpInfo(accountId = accountId, methodName = methodName, execGetMethodWithBodyForBlockchainAccountRequest = execGetMethodWithBodyForBlockchainAccountRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as MethodExecutionResult
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun execGetMethodWithBodyForBlockchainAccountWithHttpInfo(accountId: kotlin.String, methodName: kotlin.String, execGetMethodWithBodyForBlockchainAccountRequest: ExecGetMethodWithBodyForBlockchainAccountRequest?) : ApiResponse<MethodExecutionResult?> {
        val localVariableConfig = execGetMethodWithBodyForBlockchainAccountRequestConfig(accountId = accountId, methodName = methodName, execGetMethodWithBodyForBlockchainAccountRequest = execGetMethodWithBodyForBlockchainAccountRequest)

        return request<ExecGetMethodWithBodyForBlockchainAccountRequest, MethodExecutionResult>(
            localVariableConfig
        )
    }

    fun execGetMethodWithBodyForBlockchainAccountRequestConfig(accountId: kotlin.String, methodName: kotlin.String, execGetMethodWithBodyForBlockchainAccountRequest: ExecGetMethodWithBodyForBlockchainAccountRequest?) : RequestConfig<ExecGetMethodWithBodyForBlockchainAccountRequest> {
        val localVariableBody = execGetMethodWithBodyForBlockchainAccountRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/blockchain/accounts/{account_id}/methods/{method_name}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())).replace("{"+"method_name"+"}", encodeURIComponent(methodName.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sortOrder
     */
     enum class SortOrderGetBlockchainAccountTransactions(val value: kotlin.String) {
         @SerialName(value = "desc") desc("desc"),
         @SerialName(value = "asc") asc("asc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainAccountTransactions(accountId: kotlin.String, afterLt: kotlin.Long? = null, beforeLt: kotlin.Long? = null, limit: kotlin.Int? = 100, sortOrder: SortOrderGetBlockchainAccountTransactions? = SortOrderGetBlockchainAccountTransactions.desc) : Transactions {
        val localVarResponse = getBlockchainAccountTransactionsWithHttpInfo(accountId = accountId, afterLt = afterLt, beforeLt = beforeLt, limit = limit, sortOrder = sortOrder)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainAccountTransactionsWithHttpInfo(accountId: kotlin.String, afterLt: kotlin.Long?, beforeLt: kotlin.Long?, limit: kotlin.Int?, sortOrder: SortOrderGetBlockchainAccountTransactions?) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainAccountTransactionsRequestConfig(accountId = accountId, afterLt = afterLt, beforeLt = beforeLt, limit = limit, sortOrder = sortOrder)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    fun getBlockchainAccountTransactionsRequestConfig(accountId: kotlin.String, afterLt: kotlin.Long?, beforeLt: kotlin.Long?, limit: kotlin.Int?, sortOrder: SortOrderGetBlockchainAccountTransactions?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (afterLt != null) {
                    put("after_lt", listOf(afterLt.toString()))
                }
                if (beforeLt != null) {
                    put("before_lt", listOf(beforeLt.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sortOrder != null) {
                    put("sort_order", listOf(sortOrder.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}/transactions".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainBlock(blockId: kotlin.String) : BlockchainBlock {
        val localVarResponse = getBlockchainBlockWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlock
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainBlockWithHttpInfo(blockId: kotlin.String) : ApiResponse<BlockchainBlock?> {
        val localVariableConfig = getBlockchainBlockRequestConfig(blockId = blockId)

        return request<Unit, BlockchainBlock>(
            localVariableConfig
        )
    }

    fun getBlockchainBlockRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/blocks/{block_id}".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainBlockTransactions(blockId: kotlin.String) : Transactions {
        val localVarResponse = getBlockchainBlockTransactionsWithHttpInfo(blockId = blockId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainBlockTransactionsWithHttpInfo(blockId: kotlin.String) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainBlockTransactionsRequestConfig(blockId = blockId)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    fun getBlockchainBlockTransactionsRequestConfig(blockId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/blocks/{block_id}/transactions".replace("{"+"block_id"+"}", encodeURIComponent(blockId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainConfig() : BlockchainConfig {
        val localVarResponse = getBlockchainConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainConfigWithHttpInfo() : ApiResponse<BlockchainConfig?> {
        val localVariableConfig = getBlockchainConfigRequestConfig()

        return request<Unit, BlockchainConfig>(
            localVariableConfig
        )
    }

    fun getBlockchainConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainConfigFromBlock(masterchainSeqno: kotlin.Int) : BlockchainConfig {
        val localVarResponse = getBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainConfig?> {
        val localVariableConfig = getBlockchainConfigFromBlockRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainConfig>(
            localVariableConfig
        )
    }

    fun getBlockchainConfigFromBlockRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/config".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainBlocks(masterchainSeqno: kotlin.Int) : BlockchainBlocks {
        val localVarResponse = getBlockchainMasterchainBlocksWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlocks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainBlocksWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainBlocks?> {
        val localVariableConfig = getBlockchainMasterchainBlocksRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainBlocks>(
            localVariableConfig
        )
    }

    fun getBlockchainMasterchainBlocksRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/blocks".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainHead() : BlockchainBlock {
        val localVarResponse = getBlockchainMasterchainHeadWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlock
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainHeadWithHttpInfo() : ApiResponse<BlockchainBlock?> {
        val localVariableConfig = getBlockchainMasterchainHeadRequestConfig()

        return request<Unit, BlockchainBlock>(
            localVariableConfig
        )
    }

    fun getBlockchainMasterchainHeadRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain-head",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainShards(masterchainSeqno: kotlin.Int) : BlockchainBlockShards {
        val localVarResponse = getBlockchainMasterchainShardsWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainBlockShards
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainShardsWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<BlockchainBlockShards?> {
        val localVariableConfig = getBlockchainMasterchainShardsRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, BlockchainBlockShards>(
            localVariableConfig
        )
    }

    fun getBlockchainMasterchainShardsRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/shards".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainMasterchainTransactions(masterchainSeqno: kotlin.Int) : Transactions {
        val localVarResponse = getBlockchainMasterchainTransactionsWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainMasterchainTransactionsWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<Transactions?> {
        val localVariableConfig = getBlockchainMasterchainTransactionsRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    fun getBlockchainMasterchainTransactionsRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/transactions".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainRawAccount(accountId: kotlin.String) : BlockchainRawAccount {
        val localVarResponse = getBlockchainRawAccountWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainRawAccount
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainRawAccountWithHttpInfo(accountId: kotlin.String) : ApiResponse<BlockchainRawAccount?> {
        val localVariableConfig = getBlockchainRawAccountRequestConfig(accountId = accountId)

        return request<Unit, BlockchainRawAccount>(
            localVariableConfig
        )
    }

    fun getBlockchainRawAccountRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/accounts/{account_id}".replace("{"+"account_id"+"}", encodeURIComponent(accountId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainTransaction(transactionId: kotlin.String) : Transaction {
        val localVarResponse = getBlockchainTransactionWithHttpInfo(transactionId = transactionId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transaction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainTransactionWithHttpInfo(transactionId: kotlin.String) : ApiResponse<Transaction?> {
        val localVariableConfig = getBlockchainTransactionRequestConfig(transactionId = transactionId)

        return request<Unit, Transaction>(
            localVariableConfig
        )
    }

    fun getBlockchainTransactionRequestConfig(transactionId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/transactions/{transaction_id}".replace("{"+"transaction_id"+"}", encodeURIComponent(transactionId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainTransactionByMessageHash(msgId: kotlin.String) : Transaction {
        val localVarResponse = getBlockchainTransactionByMessageHashWithHttpInfo(msgId = msgId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transaction
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainTransactionByMessageHashWithHttpInfo(msgId: kotlin.String) : ApiResponse<Transaction?> {
        val localVariableConfig = getBlockchainTransactionByMessageHashRequestConfig(msgId = msgId)

        return request<Unit, Transaction>(
            localVariableConfig
        )
    }

    fun getBlockchainTransactionByMessageHashRequestConfig(msgId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/messages/{msg_id}/transaction".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBlockchainValidators() : Validators {
        val localVarResponse = getBlockchainValidatorsWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Validators
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBlockchainValidatorsWithHttpInfo() : ApiResponse<Validators?> {
        val localVariableConfig = getBlockchainValidatorsRequestConfig()

        return request<Unit, Validators>(
            localVariableConfig
        )
    }

    fun getBlockchainValidatorsRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/validators",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLibraryByHash(hash: kotlin.String) : BlockchainLibrary {
        val localVarResponse = getLibraryByHashWithHttpInfo(hash = hash)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BlockchainLibrary
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLibraryByHashWithHttpInfo(hash: kotlin.String) : ApiResponse<BlockchainLibrary?> {
        val localVariableConfig = getLibraryByHashRequestConfig(hash = hash)

        return request<Unit, BlockchainLibrary>(
            localVariableConfig
        )
    }

    fun getLibraryByHashRequestConfig(hash: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/libraries/{hash}".replace("{"+"hash"+"}", encodeURIComponent(hash.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainConfig() : RawBlockchainConfig {
        val localVarResponse = getRawBlockchainConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RawBlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainConfigWithHttpInfo() : ApiResponse<RawBlockchainConfig?> {
        val localVariableConfig = getRawBlockchainConfigRequestConfig()

        return request<Unit, RawBlockchainConfig>(
            localVariableConfig
        )
    }

    fun getRawBlockchainConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/config/raw",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRawBlockchainConfigFromBlock(masterchainSeqno: kotlin.Int) : RawBlockchainConfig {
        val localVarResponse = getRawBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno = masterchainSeqno)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RawBlockchainConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRawBlockchainConfigFromBlockWithHttpInfo(masterchainSeqno: kotlin.Int) : ApiResponse<RawBlockchainConfig?> {
        val localVariableConfig = getRawBlockchainConfigFromBlockRequestConfig(masterchainSeqno = masterchainSeqno)

        return request<Unit, RawBlockchainConfig>(
            localVariableConfig
        )
    }

    fun getRawBlockchainConfigFromBlockRequestConfig(masterchainSeqno: kotlin.Int) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/masterchain/{masterchain_seqno}/config/raw".replace("{"+"masterchain_seqno"+"}", encodeURIComponent(masterchainSeqno.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getReducedBlockchainBlocks(from: kotlin.Long, to: kotlin.Long) : ReducedBlocks {
        val localVarResponse = getReducedBlockchainBlocksWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ReducedBlocks
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getReducedBlockchainBlocksWithHttpInfo(from: kotlin.Long, to: kotlin.Long) : ApiResponse<ReducedBlocks?> {
        val localVariableConfig = getReducedBlockchainBlocksRequestConfig(from = from, to = to)

        return request<Unit, ReducedBlocks>(
            localVariableConfig
        )
    }

    fun getReducedBlockchainBlocksRequestConfig(from: kotlin.Long, to: kotlin.Long) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("from", listOf(from.toString()))
                put("to", listOf(to.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/blockchain/reduced/blocks",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendBlockchainMessage(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : Unit {
        val localVarResponse = sendBlockchainMessageWithHttpInfo(sendBlockchainMessageRequest = sendBlockchainMessageRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }


    @Throws(IllegalStateException::class, IOException::class)
    fun sendBlockchainMessageWithHttpInfo(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sendBlockchainMessageRequestConfig(sendBlockchainMessageRequest = sendBlockchainMessageRequest)

        return request<SendBlockchainMessageRequest, Unit>(
            localVariableConfig
        )
    }

    fun sendBlockchainMessageRequestConfig(sendBlockchainMessageRequest: SendBlockchainMessageRequest) : RequestConfig<SendBlockchainMessageRequest> {
        val localVariableBody = sendBlockchainMessageRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v2/blockchain/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
