/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package io.batteryapi.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import io.batteryapi.models.AndroidBatteryPurchaseRequest
import io.batteryapi.models.AndroidBatteryPurchaseStatus
import io.batteryapi.models.AppStoreNotificationRequest
import io.batteryapi.models.ApplyPromoRequest
import io.batteryapi.models.Balance
import io.batteryapi.models.BatteryCharged
import io.batteryapi.models.Config
import io.batteryapi.models.CreateCustomRefundRequest
import io.batteryapi.models.CreatePromoCampaign200Response
import io.batteryapi.models.CreatePromoCampaignRequest
import io.batteryapi.models.EmulateMessageToWalletRequest
import io.batteryapi.models.EnterpriseEstimate200Response
import io.batteryapi.models.EnterpriseEstimateRequest
import io.batteryapi.models.EnterpriseGetMessage200Response
import io.batteryapi.models.EnterpriseGetStatus200Response
import io.batteryapi.models.EnterpriseSend200Response
import io.batteryapi.models.EnterpriseWalletConfig
import io.batteryapi.models.EstimateGaslessCostRequest
import io.batteryapi.models.EstimatedTronTx
import io.batteryapi.models.GaslessEstimation
import io.batteryapi.models.GetTronConfig200Response
import io.batteryapi.models.IOSBatteryPurchaseStatus
import io.batteryapi.models.IncreaseUserBalanceRequest
import io.batteryapi.models.InlineObject
import io.batteryapi.models.IosBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseRequest
import io.batteryapi.models.PromoCodeBatteryPurchaseStatus
import io.batteryapi.models.PromoUsed
import io.batteryapi.models.Purchases
import io.batteryapi.models.RechargeMethods
import io.batteryapi.models.RequestRefundRequest
import io.batteryapi.models.ResetUserBalanceRequest
import io.batteryapi.models.SentTronTx
import io.batteryapi.models.Status
import io.batteryapi.models.Transactions
import io.batteryapi.models.TronSendRequest
import io.batteryapi.models.TronTransactionsList
import io.batteryapi.models.VerifyPurchasePromo200Response

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable

import io.infrastructure.ApiClient
import io.infrastructure.ApiResponse
import io.infrastructure.ClientException
import io.infrastructure.ClientError
import io.infrastructure.ServerException
import io.infrastructure.ServerError
import io.infrastructure.MultiValueMap
import io.infrastructure.PartConfig
import io.infrastructure.RequestConfig
import io.infrastructure.RequestMethod
import io.infrastructure.ResponseType
import io.infrastructure.Success
import io.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://battery.tonkeeper.com")
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun androidBatteryPurchase(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : AndroidBatteryPurchaseStatus {
        val localVarResponse = androidBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as AndroidBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun androidBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : ApiResponse<AndroidBatteryPurchaseStatus?> {
        val localVariableConfig = androidBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, androidBatteryPurchaseRequest = androidBatteryPurchaseRequest)

        return request<AndroidBatteryPurchaseRequest, AndroidBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    fun androidBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, androidBatteryPurchaseRequest: AndroidBatteryPurchaseRequest) : RequestConfig<AndroidBatteryPurchaseRequest> {
        val localVariableBody = androidBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/android",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun appStoreNotification(appStoreNotificationRequest: AppStoreNotificationRequest) : kotlin.Any {
        val localVarResponse = appStoreNotificationWithHttpInfo(appStoreNotificationRequest = appStoreNotificationRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.Any
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun appStoreNotificationWithHttpInfo(appStoreNotificationRequest: AppStoreNotificationRequest) : ApiResponse<kotlin.Any?> {
        val localVariableConfig = appStoreNotificationRequestConfig(appStoreNotificationRequest = appStoreNotificationRequest)

        return request<AppStoreNotificationRequest, kotlin.Any>(
            localVariableConfig
        )
    }

    fun appStoreNotificationRequestConfig(appStoreNotificationRequest: AppStoreNotificationRequest) : RequestConfig<AppStoreNotificationRequest> {
        val localVariableBody = appStoreNotificationRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios/app-store-notification",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun applyPromo(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : PromoCodeBatteryPurchaseStatus {
        val localVarResponse = applyPromoWithHttpInfo(token = token, applyPromoRequest = applyPromoRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoCodeBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun applyPromoWithHttpInfo(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : ApiResponse<PromoCodeBatteryPurchaseStatus?> {
        val localVariableConfig = applyPromoRequestConfig(token = token, applyPromoRequest = applyPromoRequest)

        return request<ApplyPromoRequest, PromoCodeBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    fun applyPromoRequestConfig(token: kotlin.String, applyPromoRequest: ApplyPromoRequest) : RequestConfig<ApplyPromoRequest> {
        val localVariableBody = applyPromoRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/apply-promo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createCustomRefund(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : kotlin.collections.Map<kotlin.String, io.JsonAny> {
        val localVarResponse = createCustomRefundWithHttpInfo(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, io.JsonAny>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createCustomRefundWithHttpInfo(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, io.JsonAny>?> {
        val localVariableConfig = createCustomRefundRequestConfig(token = token, createCustomRefundRequest = createCustomRefundRequest)

        return request<CreateCustomRefundRequest, kotlin.collections.Map<kotlin.String, io.JsonAny>>(
            localVariableConfig
        )
    }

    fun createCustomRefundRequestConfig(token: kotlin.String, createCustomRefundRequest: CreateCustomRefundRequest) : RequestConfig<CreateCustomRefundRequest> {
        val localVariableBody = createCustomRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/create-custom-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun createPromoCampaign(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : CreatePromoCampaign200Response {
        val localVarResponse = createPromoCampaignWithHttpInfo(token = token, createPromoCampaignRequest = createPromoCampaignRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as CreatePromoCampaign200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun createPromoCampaignWithHttpInfo(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : ApiResponse<CreatePromoCampaign200Response?> {
        val localVariableConfig = createPromoCampaignRequestConfig(token = token, createPromoCampaignRequest = createPromoCampaignRequest)

        return request<CreatePromoCampaignRequest, CreatePromoCampaign200Response>(
            localVariableConfig
        )
    }

    fun createPromoCampaignRequestConfig(token: kotlin.String, createPromoCampaignRequest: CreatePromoCampaignRequest) : RequestConfig<CreatePromoCampaignRequest> {
        val localVariableBody = createPromoCampaignRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/promo-campaign",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseEstimate(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String? = "en", emulate: kotlin.Boolean? = false) : EnterpriseEstimate200Response {
        val localVarResponse = enterpriseEstimateWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest, acceptLanguage = acceptLanguage, emulate = emulate)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseEstimate200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseEstimateWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String?, emulate: kotlin.Boolean?) : ApiResponse<EnterpriseEstimate200Response?> {
        val localVariableConfig = enterpriseEstimateRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest, acceptLanguage = acceptLanguage, emulate = emulate)

        return request<EnterpriseEstimateRequest, EnterpriseEstimate200Response>(
            localVariableConfig
        )
    }

    fun enterpriseEstimateRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest, acceptLanguage: kotlin.String?, emulate: kotlin.Boolean?) : RequestConfig<EnterpriseEstimateRequest> {
        val localVariableBody = enterpriseEstimateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (emulate != null) {
                    put("emulate", listOf(emulate.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/enterprise/wallets/{wallet_id}/estimate".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetMessage(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : EnterpriseGetMessage200Response {
        val localVarResponse = enterpriseGetMessageWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, msgId = msgId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseGetMessage200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetMessageWithHttpInfo(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : ApiResponse<EnterpriseGetMessage200Response?> {
        val localVariableConfig = enterpriseGetMessageRequestConfig(xEnterpriseAuth = xEnterpriseAuth, msgId = msgId)

        return request<Unit, EnterpriseGetMessage200Response>(
            localVariableConfig
        )
    }

    fun enterpriseGetMessageRequestConfig(xEnterpriseAuth: kotlin.String, msgId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/messages/{msg_id}".replace("{"+"msg_id"+"}", encodeURIComponent(msgId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetStatus(xEnterpriseAuth: kotlin.String) : EnterpriseGetStatus200Response {
        val localVarResponse = enterpriseGetStatusWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseGetStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetStatusWithHttpInfo(xEnterpriseAuth: kotlin.String) : ApiResponse<EnterpriseGetStatus200Response?> {
        val localVariableConfig = enterpriseGetStatusRequestConfig(xEnterpriseAuth = xEnterpriseAuth)

        return request<Unit, EnterpriseGetStatus200Response>(
            localVariableConfig
        )
    }

    fun enterpriseGetStatusRequestConfig(xEnterpriseAuth: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseGetWalletConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : EnterpriseWalletConfig {
        val localVarResponse = enterpriseGetWalletConfigWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseWalletConfig
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseGetWalletConfigWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : ApiResponse<EnterpriseWalletConfig?> {
        val localVariableConfig = enterpriseGetWalletConfigRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId)

        return request<Unit, EnterpriseWalletConfig>(
            localVariableConfig
        )
    }

    fun enterpriseGetWalletConfigRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/enterprise/wallets/{wallet_id}/config".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun enterpriseSend(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : EnterpriseSend200Response {
        val localVarResponse = enterpriseSendWithHttpInfo(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EnterpriseSend200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun enterpriseSendWithHttpInfo(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : ApiResponse<EnterpriseSend200Response?> {
        val localVariableConfig = enterpriseSendRequestConfig(xEnterpriseAuth = xEnterpriseAuth, walletId = walletId, enterpriseEstimateRequest = enterpriseEstimateRequest)

        return request<EnterpriseEstimateRequest, EnterpriseSend200Response>(
            localVariableConfig
        )
    }

    fun enterpriseSendRequestConfig(xEnterpriseAuth: kotlin.String, walletId: kotlin.String, enterpriseEstimateRequest: EnterpriseEstimateRequest) : RequestConfig<EnterpriseEstimateRequest> {
        val localVariableBody = enterpriseEstimateRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xEnterpriseAuth.apply { localVariableHeaders["X-Enterprise-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/enterprise/wallets/{wallet_id}/send".replace("{"+"wallet_id"+"}", encodeURIComponent(walletId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun estimateGaslessCost(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String? = null, walletAddress: kotlin.String? = null, walletPublicKey: kotlin.String? = null, enableValidation: kotlin.Boolean? = false) : GaslessEstimation {
        val localVarResponse = estimateGaslessCostWithHttpInfo(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey, enableValidation = enableValidation)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GaslessEstimation
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun estimateGaslessCostWithHttpInfo(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?, enableValidation: kotlin.Boolean?) : ApiResponse<GaslessEstimation?> {
        val localVariableConfig = estimateGaslessCostRequestConfig(jettonMaster = jettonMaster, estimateGaslessCostRequest = estimateGaslessCostRequest, xTonConnectAuth = xTonConnectAuth, walletAddress = walletAddress, walletPublicKey = walletPublicKey, enableValidation = enableValidation)

        return request<EstimateGaslessCostRequest, GaslessEstimation>(
            localVariableConfig
        )
    }

    fun estimateGaslessCostRequestConfig(jettonMaster: kotlin.String, estimateGaslessCostRequest: EstimateGaslessCostRequest, xTonConnectAuth: kotlin.String?, walletAddress: kotlin.String?, walletPublicKey: kotlin.String?, enableValidation: kotlin.Boolean?) : RequestConfig<EstimateGaslessCostRequest> {
        val localVariableBody = estimateGaslessCostRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (walletAddress != null) {
                    put("wallet_address", listOf(walletAddress.toString()))
                }
                if (walletPublicKey != null) {
                    put("wallet_public_key", listOf(walletPublicKey.toString()))
                }
                if (enableValidation != null) {
                    put("enable_validation", listOf(enableValidation.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth?.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/gasless/estimate-cost/{jetton_master}".replace("{"+"jetton_master"+"}", encodeURIComponent(jettonMaster.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun extendRefundPeriod(purchaseId: kotlin.Long, token: kotlin.String) : kotlin.collections.Map<kotlin.String, io.JsonAny> {
        val localVarResponse = extendRefundPeriodWithHttpInfo(purchaseId = purchaseId, token = token)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, io.JsonAny>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun extendRefundPeriodWithHttpInfo(purchaseId: kotlin.Long, token: kotlin.String) : ApiResponse<kotlin.collections.Map<kotlin.String, io.JsonAny>?> {
        val localVariableConfig = extendRefundPeriodRequestConfig(purchaseId = purchaseId, token = token)

        return request<Unit, kotlin.collections.Map<kotlin.String, io.JsonAny>>(
            localVariableConfig
        )
    }

    fun extendRefundPeriodRequestConfig(purchaseId: kotlin.Long, token: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/purchases/{purchase_id}/extend-refund-period".replace("{"+"purchase_id"+"}", encodeURIComponent(purchaseId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter units
     */
     enum class UnitsGetBalance(val value: kotlin.String) {
         @SerialName(value = "usd") usd("usd"),
         @SerialName(value = "ton") ton("ton");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBalance(xTonConnectAuth: kotlin.String, units: UnitsGetBalance? = UnitsGetBalance.usd, region: kotlin.String? = null) : Balance {
        val localVarResponse = getBalanceWithHttpInfo(xTonConnectAuth = xTonConnectAuth, units = units, region = region)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Balance
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBalanceWithHttpInfo(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?, region: kotlin.String?) : ApiResponse<Balance?> {
        val localVariableConfig = getBalanceRequestConfig(xTonConnectAuth = xTonConnectAuth, units = units, region = region)

        return request<Unit, Balance>(
            localVariableConfig
        )
    }

    fun getBalanceRequestConfig(xTonConnectAuth: kotlin.String, units: UnitsGetBalance?, region: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (units != null) {
                    put("units", listOf(units.value))
                }
                if (region != null) {
                    put("region", listOf(region.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/balance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBatteryCharged(accountId: kotlin.String) : BatteryCharged {
        val localVarResponse = getBatteryChargedWithHttpInfo(accountId = accountId)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as BatteryCharged
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBatteryChargedWithHttpInfo(accountId: kotlin.String) : ApiResponse<BatteryCharged?> {
        val localVariableConfig = getBatteryChargedRequestConfig(accountId = accountId)

        return request<Unit, BatteryCharged>(
            localVariableConfig
        )
    }

    fun getBatteryChargedRequestConfig(accountId: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("account_id", listOf(accountId.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/battery-charged",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getConfig() : Config {
        val localVarResponse = getConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Config
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getConfigWithHttpInfo() : ApiResponse<Config?> {
        val localVariableConfig = getConfigRequestConfig()

        return request<Unit, Config>(
            localVariableConfig
        )
    }

    fun getConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPromoUsed(promo: kotlin.String) : PromoUsed {
        val localVarResponse = getPromoUsedWithHttpInfo(promo = promo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoUsed
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPromoUsedWithHttpInfo(promo: kotlin.String) : ApiResponse<PromoUsed?> {
        val localVariableConfig = getPromoUsedRequestConfig(promo = promo)

        return request<Unit, PromoUsed>(
            localVariableConfig
        )
    }

    fun getPromoUsedRequestConfig(promo: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("promo", listOf(promo.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/promo-used",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPurchases(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0, includeGiftsOnTheWay: kotlin.Boolean? = false) : Purchases {
        val localVarResponse = getPurchasesWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Purchases
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPurchasesWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : ApiResponse<Purchases?> {
        val localVariableConfig = getPurchasesRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset, includeGiftsOnTheWay = includeGiftsOnTheWay)

        return request<Unit, Purchases>(
            localVariableConfig
        )
    }

    fun getPurchasesRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?, includeGiftsOnTheWay: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (includeGiftsOnTheWay != null) {
                    put("include_gifts_on_the_way", listOf(includeGiftsOnTheWay.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchases",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRechargeMethods(includeRechargeOnly: kotlin.Boolean? = true) : RechargeMethods {
        val localVarResponse = getRechargeMethodsWithHttpInfo(includeRechargeOnly = includeRechargeOnly)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as RechargeMethods
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRechargeMethodsWithHttpInfo(includeRechargeOnly: kotlin.Boolean?) : ApiResponse<RechargeMethods?> {
        val localVariableConfig = getRechargeMethodsRequestConfig(includeRechargeOnly = includeRechargeOnly)

        return request<Unit, RechargeMethods>(
            localVariableConfig
        )
    }

    fun getRechargeMethodsRequestConfig(includeRechargeOnly: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeRechargeOnly != null) {
                    put("include_recharge_only", listOf(includeRechargeOnly.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/recharge-methods",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStatus(xTonConnectAuth: kotlin.String) : Status {
        val localVarResponse = getStatusWithHttpInfo(xTonConnectAuth = xTonConnectAuth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Status
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStatusWithHttpInfo(xTonConnectAuth: kotlin.String) : ApiResponse<Status?> {
        val localVariableConfig = getStatusRequestConfig(xTonConnectAuth = xTonConnectAuth)

        return request<Unit, Status>(
            localVariableConfig
        )
    }

    fun getStatusRequestConfig(xTonConnectAuth: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTransactions(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, offset: kotlin.Int? = 0) : Transactions {
        val localVarResponse = getTransactionsWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as Transactions
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTransactionsWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : ApiResponse<Transactions?> {
        val localVariableConfig = getTransactionsRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, offset = offset)

        return request<Unit, Transactions>(
            localVariableConfig
        )
    }

    fun getTransactionsRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, offset: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTronConfig() : GetTronConfig200Response {
        val localVarResponse = getTronConfigWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTronConfig200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTronConfigWithHttpInfo() : ApiResponse<GetTronConfig200Response?> {
        val localVariableConfig = getTronConfigRequestConfig()

        return request<Unit, GetTronConfig200Response>(
            localVariableConfig
        )
    }

    fun getTronConfigRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/config",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTronTransactions(xTonConnectAuth: kotlin.String, limit: kotlin.Int? = 1000, maxTimestamp: kotlin.Long? = null) : TronTransactionsList {
        val localVarResponse = getTronTransactionsWithHttpInfo(xTonConnectAuth = xTonConnectAuth, limit = limit, maxTimestamp = maxTimestamp)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as TronTransactionsList
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTronTransactionsWithHttpInfo(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, maxTimestamp: kotlin.Long?) : ApiResponse<TronTransactionsList?> {
        val localVariableConfig = getTronTransactionsRequestConfig(xTonConnectAuth = xTonConnectAuth, limit = limit, maxTimestamp = maxTimestamp)

        return request<Unit, TronTransactionsList>(
            localVariableConfig
        )
    }

    fun getTronTransactionsRequestConfig(xTonConnectAuth: kotlin.String, limit: kotlin.Int?, maxTimestamp: kotlin.Long?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (maxTimestamp != null) {
                    put("max_timestamp", listOf(maxTimestamp.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/transactions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun increaseUserBalance(userId: kotlin.Long, token: kotlin.String, increaseUserBalanceRequest: IncreaseUserBalanceRequest) : kotlin.collections.Map<kotlin.String, io.JsonAny> {
        val localVarResponse = increaseUserBalanceWithHttpInfo(userId = userId, token = token, increaseUserBalanceRequest = increaseUserBalanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, io.JsonAny>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun increaseUserBalanceWithHttpInfo(userId: kotlin.Long, token: kotlin.String, increaseUserBalanceRequest: IncreaseUserBalanceRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, io.JsonAny>?> {
        val localVariableConfig = increaseUserBalanceRequestConfig(userId = userId, token = token, increaseUserBalanceRequest = increaseUserBalanceRequest)

        return request<IncreaseUserBalanceRequest, kotlin.collections.Map<kotlin.String, io.JsonAny>>(
            localVariableConfig
        )
    }

    fun increaseUserBalanceRequestConfig(userId: kotlin.Long, token: kotlin.String, increaseUserBalanceRequest: IncreaseUserBalanceRequest) : RequestConfig<IncreaseUserBalanceRequest> {
        val localVariableBody = increaseUserBalanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/users/{user_id}/increase-balance".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun iosBatteryPurchase(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : IOSBatteryPurchaseStatus {
        val localVarResponse = iosBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as IOSBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun iosBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : ApiResponse<IOSBatteryPurchaseStatus?> {
        val localVariableConfig = iosBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, iosBatteryPurchaseRequest = iosBatteryPurchaseRequest)

        return request<IosBatteryPurchaseRequest, IOSBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    fun iosBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, iosBatteryPurchaseRequest: IosBatteryPurchaseRequest) : RequestConfig<IosBatteryPurchaseRequest> {
        val localVariableBody = iosBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/ios",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun itrxIoCallback(requestBody: kotlin.collections.Map<kotlin.String, io.JsonAny>) : kotlin.collections.Map<kotlin.String, io.JsonAny> {
        val localVarResponse = itrxIoCallbackWithHttpInfo(requestBody = requestBody)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, io.JsonAny>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun itrxIoCallbackWithHttpInfo(requestBody: kotlin.collections.Map<kotlin.String, io.JsonAny>) : ApiResponse<kotlin.collections.Map<kotlin.String, io.JsonAny>?> {
        val localVariableConfig = itrxIoCallbackRequestConfig(requestBody = requestBody)

        return request<kotlin.collections.Map<kotlin.String, io.JsonAny>, kotlin.collections.Map<kotlin.String, io.JsonAny>>(
            localVariableConfig
        )
    }

    fun itrxIoCallbackRequestConfig(requestBody: kotlin.collections.Map<kotlin.String, io.JsonAny>) : RequestConfig<kotlin.collections.Map<kotlin.String, io.JsonAny>> {
        val localVariableBody = requestBody
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/tron/itrx-io-callback",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun promoCodeBatteryPurchase(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String? = "en") : PromoCodeBatteryPurchaseStatus {
        val localVarResponse = promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as PromoCodeBatteryPurchaseStatus
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun promoCodeBatteryPurchaseWithHttpInfo(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : ApiResponse<PromoCodeBatteryPurchaseStatus?> {
        val localVariableConfig = promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth = xTonConnectAuth, promoCodeBatteryPurchaseRequest = promoCodeBatteryPurchaseRequest, acceptLanguage = acceptLanguage)

        return request<PromoCodeBatteryPurchaseRequest, PromoCodeBatteryPurchaseStatus>(
            localVariableConfig
        )
    }

    fun promoCodeBatteryPurchaseRequestConfig(xTonConnectAuth: kotlin.String, promoCodeBatteryPurchaseRequest: PromoCodeBatteryPurchaseRequest, acceptLanguage: kotlin.String?) : RequestConfig<PromoCodeBatteryPurchaseRequest> {
        val localVariableBody = promoCodeBatteryPurchaseRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        acceptLanguage?.apply { localVariableHeaders["Accept-Language"] = this.toString() }
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/purchase-battery/promo-code",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun requestRefund(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : Unit {
        val localVarResponse = requestRefundWithHttpInfo(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }


    @Throws(IllegalStateException::class, IOException::class)
    fun requestRefundWithHttpInfo(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : ApiResponse<Unit?> {
        val localVariableConfig = requestRefundRequestConfig(xTonConnectAuth = xTonConnectAuth, requestRefundRequest = requestRefundRequest)

        return request<RequestRefundRequest, Unit>(
            localVariableConfig
        )
    }

    fun requestRefundRequestConfig(xTonConnectAuth: kotlin.String, requestRefundRequest: RequestRefundRequest) : RequestConfig<RequestRefundRequest> {
        val localVariableBody = requestRefundRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/request-refund",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun resetUserBalance(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : kotlin.collections.Map<kotlin.String, io.JsonAny> {
        val localVarResponse = resetUserBalanceWithHttpInfo(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.Map<kotlin.String, io.JsonAny>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun resetUserBalanceWithHttpInfo(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : ApiResponse<kotlin.collections.Map<kotlin.String, io.JsonAny>?> {
        val localVariableConfig = resetUserBalanceRequestConfig(userId = userId, token = token, resetUserBalanceRequest = resetUserBalanceRequest)

        return request<ResetUserBalanceRequest, kotlin.collections.Map<kotlin.String, io.JsonAny>>(
            localVariableConfig
        )
    }

    fun resetUserBalanceRequestConfig(userId: kotlin.Long, token: kotlin.String, resetUserBalanceRequest: ResetUserBalanceRequest) : RequestConfig<ResetUserBalanceRequest> {
        val localVariableBody = resetUserBalanceRequest
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                put("token", listOf(token.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/restricted/users/{user_id}/reset-balance".replace("{"+"user_id"+"}", encodeURIComponent(userId.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun sendMessage(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : Unit {
        val localVarResponse = sendMessageWithHttpInfo(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> Unit
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }


    @Throws(IllegalStateException::class, IOException::class)
    fun sendMessageWithHttpInfo(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : ApiResponse<Unit?> {
        val localVariableConfig = sendMessageRequestConfig(xTonConnectAuth = xTonConnectAuth, emulateMessageToWalletRequest = emulateMessageToWalletRequest)

        return request<EmulateMessageToWalletRequest, Unit>(
            localVariableConfig
        )
    }

    fun sendMessageRequestConfig(xTonConnectAuth: kotlin.String, emulateMessageToWalletRequest: EmulateMessageToWalletRequest) : RequestConfig<EmulateMessageToWalletRequest> {
        val localVariableBody = emulateMessageToWalletRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/message",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tronEstimate(wallet: kotlin.String, energy: kotlin.Int? = null, bandwidth: kotlin.Int? = null) : EstimatedTronTx {
        val localVarResponse = tronEstimateWithHttpInfo(wallet = wallet, energy = energy, bandwidth = bandwidth)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as EstimatedTronTx
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tronEstimateWithHttpInfo(wallet: kotlin.String, energy: kotlin.Int?, bandwidth: kotlin.Int?) : ApiResponse<EstimatedTronTx?> {
        val localVariableConfig = tronEstimateRequestConfig(wallet = wallet, energy = energy, bandwidth = bandwidth)

        return request<Unit, EstimatedTronTx>(
            localVariableConfig
        )
    }

    fun tronEstimateRequestConfig(wallet: kotlin.String, energy: kotlin.Int?, bandwidth: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (energy != null) {
                    put("energy", listOf(energy.toString()))
                }
                if (bandwidth != null) {
                    put("bandwidth", listOf(bandwidth.toString()))
                }
                put("wallet", listOf(wallet.toString()))
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v0/tron/estimate",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun tronSend(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : SentTronTx {
        val localVarResponse = tronSendWithHttpInfo(xTonConnectAuth = xTonConnectAuth, tronSendRequest = tronSendRequest)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as SentTronTx
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun tronSendWithHttpInfo(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : ApiResponse<SentTronTx?> {
        val localVariableConfig = tronSendRequestConfig(xTonConnectAuth = xTonConnectAuth, tronSendRequest = tronSendRequest)

        return request<TronSendRequest, SentTronTx>(
            localVariableConfig
        )
    }

    fun tronSendRequestConfig(xTonConnectAuth: kotlin.String, tronSendRequest: TronSendRequest) : RequestConfig<TronSendRequest> {
        val localVariableBody = tronSendRequest
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        xTonConnectAuth.apply { localVariableHeaders["X-TonConnect-Auth"] = this.toString() }
        localVariableHeaders["Content-Type"] = "application/json"
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.POST,
            path = "/v0/tron/send",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun verifyPurchasePromo(promo: kotlin.String? = null) : VerifyPurchasePromo200Response {
        val localVarResponse = verifyPurchasePromoWithHttpInfo(promo = promo)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as VerifyPurchasePromo200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun verifyPurchasePromoWithHttpInfo(promo: kotlin.String?) : ApiResponse<VerifyPurchasePromo200Response?> {
        val localVariableConfig = verifyPurchasePromoRequestConfig(promo = promo)

        return request<Unit, VerifyPurchasePromo200Response>(
            localVariableConfig
        )
    }

    fun verifyPurchasePromoRequestConfig(promo: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (promo != null) {
                    put("promo", listOf(promo.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/purchase-battery/verify-purchase-promo",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = false,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
